data_AT = data_sim[which(is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
prob1     <- predict(m1, data_AT, type = "response")
pred1     <- as.numeric(mapply(tirage, prob1))
prob2     <- predict(m2, data_AT, type = "response")
pred2     <- as.numeric(mapply(tirage, prob2))
data_AT$yhat <- ifelse(pred1 == 1, "exit", "no_exit")
data_AT$yhat[which(pred1 == 1 & pred2 == 1)] <- "exit_next"
data_AT$yhat[which(pred1 == 1 & pred2 == 0)] <- "exit_oth"
if (length(unique(data_sim$grade)) > 4)
{
data_noAT = data_sim[which(!is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_noAT$yhat = "no_exit"
data_sim = rbind(data_AT, data_noAT)
}
if (length(unique(data_sim$grade)) <= 4)
{
data_sim = data_AT
}
data_sim = data_sim[order(data_sim$ident), ]
return(data_sim)
}
## Simulation for sequential
m = 1
modelname  =  paste0("MS_", toString(m))
for (annee in 2011:2012)
{
if (annee == 2011)
{
data_sim = generate_data_sim(data_path, use = "min")
output = data_sim[, c("ident", "annee", "grade","ib", "anciennete_dans_echelon", "echelon")]
output = rename(output, c("grade"=paste0("grade_", modelname) ,
"ib"=paste0("ib_", modelname),
"anciennete_dans_echelon"=paste0("anciennete_dans_echelon_", modelname),
"echelon"=paste0("echelon_", modelname)))
output[, paste0("situation_", modelname)] = NA
}
# Prediction of next_situation from estimated model
pred =  predict_next_year_seq(data_sim, step1, step2, modelname)
save_prediction_R(data = pred, annee, simul_path, modelname)
# Prediction of next_ib using simulation.py
launch_prediction_Py(annee, modelname)
# Load
simul_py = load_simul_py(annee, modelname)
# Incrementing data_sim for next year
data_sim = increment_data_sim(data_sim, simul_py)
# Save results
output = save_results_simul(output, data_sim, modelname)
}
table(data_sim$situation)
load(paste0(save_model_path, "m1_by_grade.rda"))
################ Estimation by multinomial logit ################
# Main data
source(paste0(wd, "0_Outils_CNRACL.R"))
datasets = load_and_clean(data_path, "/filter/data_ATT_2011_filtered_after_duration_var_added_new.csv")
data_max = datasets[[1]]
data_min = datasets[[2]]
# Sample selection
data_est = data_min
data_est = data_est[which(data_est$left_censored == F & data_est$annee == 2011 & data_est$generation < 1990),]
data_est = create_variables(data_est)
#### I. Simple logit ####
data_est$next_year = as.character(data_est$next_grade_situation)
data_est$duration2 = data_est$time^2
data_est$duration3 = data_est$time^3
estim = mlogit.data(data_est, shape = "wide", choice = "next_year")
mlog0 = mlogit(next_year ~ 0 | 1, data = estim, reflevel = "no_exit")
mlog1 = mlogit(next_year ~ 0 | sexe + generation_group2, data = estim, reflevel = "no_exit")
mlog2 = mlogit(next_year ~ 0 | sexe + generation_group2 + grade, data = estim, reflevel = "no_exit")
mlog3 = mlogit(next_year ~ 0 | sexe + generation_group2 + grade + duration + duration2 + duration3, data = estim, reflevel = "no_exit")
mlog4 = mlogit(next_year ~ 0 | sexe + generation_group2 + grade + I_bothC, data = estim, reflevel = "no_exit")
mlog5 = mlogit(next_year ~ 0 | sexe + generation_group2 + grade + I_bothC + I_bothE,
data = estim, reflevel = "no_exit")
mlog6 = mlogit(next_year ~ 0 | sexe + generation_group2 + grade +
I_bothC + I_bothE + duration + duration2 + duration3,
data = estim, reflevel = "no_exit")
list_MNL = list(mlog0, mlog3, mlog6)
save(list_MNL, file = paste0(save_model_path, "mlog.rda"))
# bundle up some models
m1 = extract.mlogit2(mlog1)
m2 = extract.mlogit2(mlog2)
m3 = extract.mlogit2(mlog3)
m4 = extract.mlogit2(mlog4)
m5 = extract.mlogit2(mlog5)
m6 = extract.mlogit2(mlog6)
model.list <- list(m1, m2, m3, m4, m5, m6)
name.map <- list("exit_next:(intercept)"       = "exit_next: constante",
"exit_next:sexeM"             = "exit_next: Homme",
"exit_next:generation_group22"= "exit_next: Generation 70s",
"exit_next:generation_group23"= "exit_next: Generation 80s",
"exit_next:gradeTTH2"    = "exit_next: TTH2",
"exit_next:gradeTTH3"    = "exit_next: TTH3",
"exit_next:gradeTTH4"    = "exit_next: TTH4",
"exit_next:I_bothC"            = "exit_next: Conditions choix remplies",
"exit_next:I_bothE"            = "exit_next: Conditions exam remplies",
"exit_oth:(intercept)"        = "exit_oth: constante",
"exit_oth:sexeM"              = "exit_oth: Homme",
"exit_oth:generation_group22" = "exit_oth: Generation 70s",
"exit_oth:generation_group23" = "exit_oth: Generation 80s",
"exit_oth:gradeTTH2"     = "exit_oth: TTH2",
"exit_oth:gradeTTH3"     = "exit_oth: TTH3",
"exit_oth:gradeTTH4"     = "exit_oth: TTH4",
"exit_oth:I_bothC"            = "exit_oth: Conditions choix remplies",
"exit_oth:I_bothE"            = "exit_oth: Conditions exam remplies")
oldnames <- all.varnames.dammit(model.list)
ror <- build.ror(oldnames, name.map)
print(texreg2(model.list,
caption.above=F,
float.pos = "!ht",
digit=3,
stars = c(0.01, 0.05, 0.1),
custom.coef.names=ror$ccn,   reorder.coef=ror$rc,  omit.coef=ror$oc,
booktabs=T))
#### II. One logit by Grade ####
list1 = which(estim$grade == "TTH1")
list2 = which(estim$grade == "TTH2")
list3 = which(estim$grade == "TTH3")
list4 = which(data_est$grade == "TTH4")
data_est$exit2 = ifelse(data_est$next_year == 'exit_oth',1, 0)
m1_all = mlogit(next_year ~ 0 | sexe + generation_group2 + grade +
I_bothC + I_bothE + duration + duration2 + duration3,
data = estim, reflevel = "no_exit")
m1_TTH1 = mlogit(next_year ~ 0 | sexe + generation_group2 +
I_bothC + I_bothE + duration + duration2 + duration3,
data = estim[list1, ], reflevel = "no_exit")
m1_TTH2 = mlogit(next_year ~ 0 | sexe + generation_group2 +
I_bothC +  duration + duration2 + duration3,
data = estim[list2, ], reflevel = "no_exit")
m1_TTH3 = mlogit(next_year ~ 0 | sexe + generation_group2 +
I_bothC +  duration + duration2 + duration3,
data = estim[list3, ], reflevel = "no_exit")
m1_TTH4 = glm(exit2 ~  sexe + generation_group2 +
duration + duration2 + duration3,
data = data_est[list4, ], x=T, family=binomial("logit"))
save(mTTH1, mTTH2, mTTH3, mTTH4, file = paste0(save_model_path, "by_grade.rda"))
m1 = extract.mlogit2(mlog1)
m2 = extract.mlogit2(mlog2)
m3 = extract.mlogit2(mlog3)
m4 = extract.mlogit2(mlog4)
m5 = extract.glm2(mlog5, include.aic =  F, include.bic = F, include.deviance =  F)
model.list <- list(m2, m3, m4, m5)
name.map <- list("exit_next:(intercept)"       = "exit_next: constante",
"exit_next:sexeM"             = "exit_next: Homme",
"exit_next:generation_group22" = "exit_next: Generation 70s",
"exit_next:generation_group23 "= "exit_next: Generation 80s",
"exit_next:I_bothC"            = "exit_next: Conditions choix remplies",
"exit_next:I_bothE"            = "exit_next: Conditions exam remplies",
"exit_oth:(intercept)"        = "exit_oth: constante",
"exit_oth:sexeM"              = "exit_oth: Homme",
"exit_oth:generation_group22" = "exit_oth: Generation 70s",
"exit_oth:generation_group23" = "exit_oth: Generation 80s",
"exit_oth:I_bothC"            = "exit_oth: Conditions choix remplies",
"exit_oth:I_bothE"            = "exit_oth: Conditions exam remplies",
"(intercept)"        = "Constante",
"sexeM"              = "Homme",
"generation_group22" = "Generation 70s",
"generation_group23" = "Generation 80s")
oldnames <- all.varnames.dammit(model.list)
ror <- build.ror(oldnames, name.map)
print(texreg2(model.list,
caption.above=T,
custom.model.names = c("TTH1", "TTH2","TTH3", "TTH4"),
float.pos = "!ht",
digit=3,
stars = c(0.01, 0.05, 0.1),
custom.coef.names=ror$ccn,   reorder.coef=ror$rc,  omit.coef=ror$oc,
booktabs=T))
#### III. Sequential logit ####
# Step 1:
data_est$exit = ifelse(data_est$next_year == 'exit_oth' | data_est$next_year =='exit_next', 1, 0)
step1 <- glm(exit ~  sexe + generation_group2 + grade +
I_bothC + I_bothE + duration + duration2 + duration3,
data=data_est, x=T, family=binomial("logit"))
# Step 2:
data_est2 = data_est[which(data_est$exit == 1), ]
data_est2$exit_next = ifelse(data_est2$next_year =='exit_next', 1, 0)
step2 <- glm(exit_next ~  sexe + generation_group2 + grade +
I_bothC + I_bothE + duration + duration2 + duration3,
data=data_est2 , x=T, family=binomial("logit"))
save(step1, step2, file = paste0(save_model_path, "seq.rda"))
m1 = extract.glm2(step1)
m2 = extract.glm2(step2)
model.list <- list(m1, m2)
name.map <- list("(intercept)"        = "Constante",
"sexeM"              = "Homme",
"generation_group22" = "Generation 70s",
"generation_group23" = "Generation 80s",
"gradeTTH2"     = "TTH2",
"gradeTTH3"     = "TTH3",
"gradeTTH4"     = "TTH4",
"I_bothC"            = "Conditions choix remplies",
"I_bothE"            = "Conditions exam remplies")
oldnames <- all.varnames.dammit(model.list)
ror <- build.ror(oldnames, name.map)
print(texreg2(model.list,
caption.above=T,
custom.model.names = c("Etape 1: exit vs. no exit", "Etape 2: exit\\_next vs. exit\\_oth"),
float.pos = "!ht",
digit=3,
stars = c(0.01, 0.05, 0.1),
custom.coef.names=ror$ccn,   reorder.coef=ror$rc,  omit.coef=ror$oc,
booktabs=T))
##  Paths ####
rm(list = ls()); gc()
user = "simrab"
if (user == "simrab")
{
wd =  'U:/Projets/CNRACL/fonction-publique/fonction_publique/estimation/'
data_path = "M:/CNRACL/output/"
save_model_path = "Q:/CNRACL/predictions/"
simul_path  = "M:/CNRACL/simulation/results/"
python_file_path = 'U:/Projets/CNRACL/fonction-publique/fonction_publique/estimation/'
git_path =  'XXX/IPP/CNRACL'
fig_path = "Q:/CNRACL/Note CNRACL/Figures/"
tab_path = "Q:/CNRACL/Note CNRACL/Figures/"
}
setwd(wd)
################ Simulation with multinomial logit ################
# Simulation of trajectories based on estimation of the model.
# Two types of simulations:
#     i) Simulation of grade exit (2011 --> 2015)
#     ii)  Simulation of next ib (2011 --> 2012)
# Program:
# 0.  Initialisation: data loading and variable creations
# I.  Estimation: estimation of the models for predictions
# II. Simulation: from estimates, creating the two outputs for simulation diagnosis.
#### 0. Initialisation ####
source(paste0(wd, "0_Outils_CNRACL.R"))
load(paste0(save_model_path, "mlog.rda"))
load(paste0(save_model_path, "seq.rda"))
load(paste0(save_model_path, "by_grade.rda"))
generate_data_sim <- function(data_path, use = "min")
{
datasets = load_and_clean(data_path, dataname = "filter/data_ATT_2011_filtered_after_duration_var_added_new.csv")
if (use == "max"){data = datasets[[1]]}
if (use == "min"){data = datasets[[2]]}
list_var = c("ident", "annee",  "sexe", "c_cir_2011", "generation", "an_aff", "grade",
"E_exam", "E_choice", "D_exam", "D_choice",
"time", "anciennete_dans_echelon", "echelon", "ib")
data = data[which(data$left_censored == F  & data$annee == 2011 & data$generation < 1990),
list_var ]
data_sim  =  create_variables(data)
return(data_sim)
}
generate_data_output <- function(data_path)
{
dataname = "filter/data_ATT_2011_filtered_after_duration_var_added_new.csv"
filename = paste0(data_path, dataname)
data_long = read.csv(filename)
data_long$grade = data_long$c_cir
list_var = c("ident", "annee", "grade","ib", "echelon")
output = data_long[which(data_long$annee >= 2011 & data_long$annee <= 2015), list_var]
return(output[, list_var])
}
save_prediction_R <- function(data, annee, save_path, modelname)
{
data$corps = "ATT"
data$next_situation = data$yhat
data = data[, c("ident", "annee", "corps", "grade", "ib", "echelon", "anciennete_dans_echelon", "next_situation")]
filename = paste0(save_path, annee, "_data_simul_withR_",modelname,".csv")
write.csv(data, file = filename)
print(paste0("Data ", filename, " saved"))
}
launch_prediction_Py <- function(annee, modelname, debug = F)
{
input_name = paste0(annee, "_data_simul_withR_",modelname,".csv")
output_name = paste0(annee, "_data_simul_withPy_",modelname,".csv")
input_arg = paste0(" -i ", input_name)
output_arg = paste0(" -o ", output_name)
d = ifelse(debug, " -d", "")
args = paste0(input_arg, output_arg, d)
command =  paste0('simulation',  args)
shell(command)
}
load_simul_py <- function(annee, modelname)
{
filename = paste0(simul_path, paste0(annee, "_data_simul_withPy_",modelname,".csv"))
simul = read.csv(filename)
simul = simul[order(simul$ident),-1]
#names(simul) = c("ident", "next_annee", "next_grade", "next_echelon", "next_annicennete_dans_echelon")
return(simul)
}
predict_next_year_MNL <- function(data_sim, model, modelname)
{
adhoc <- sample(c("no_exit",   "exit_next", "exit_oth"), nrow(data_sim), replace=TRUE, prob = c(0.2, 0.2, 0.6))
data_sim$next_year <-adhoc
data_sim$grade <-as.character(data_sim$grade)
# Prediction for AT grade
data_AT = data_sim[which(is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_predict_MNL <- mlogit.data(data_AT, shape = "wide", choice = "next_year")
prob     <- predict(model, data_predict_MNL ,type = "response")
data_AT$yhat <- mapply(tirage_next_year_MNL, prob[,1], prob[,2], prob[,3])
#
if (length(unique(data_sim$grade)) > 4)
{
data_noAT = data_sim[which(!is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_noAT$yhat = "no_exit"
data_sim = rbind(data_AT, data_noAT)
}
if (length(unique(data_sim$grade)) <= 4)
{
data_sim = data_AT
}
data_sim = data_sim[order(data_sim$ident), ]
return(data_sim)
}
predict_next_year_byG <- function(data_sim, list_model, modelname)
{
adhoc <- sample(c("no_exit",   "exit_next", "exit_oth"), nrow(data_sim), replace=TRUE, prob = c(0.2, 0.2, 0.6))
data_sim$next_year <-adhoc
data_sim$grade <-as.character(data_sim$grade)
# Prediction by grade
n = names(data_sim)
data_merge = as.data.frame(setNames(replicate(length(n),numeric(0), simplify = F), n))
for (g in 1:length(list_grade))
{
data = data_sim[which(data_sim$grade == list_grade[g]), ]
mlogit.data(data, shape = "wide", choice = "next_year")
prob     <- predict(list_model[g], data_predict1 ,type = "response")
data$yhat = mapply(tirage_next_year_MNL, prob[,1], prob[,2], prob[,3])
data_merge = rbind(data_merge, data)
}
if (length(unique(data_sim$grade)) > 4)
{
data_noAT = data_sim[which(!is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_noAT$yhat = "no_exit"
data_sim = rbind(data_merge, data_noAT)
}
else{
data_sim =  data_merge
}
data_sim = data_sim[order(data_sim$ident), ]
return(data_sim)
}
predict_next_year_seq <- function(data_sim, m1, m2, modelname)
{
# Prediction for AT grade
data_AT = data_sim[which(is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
prob1     <- predict(m1, data_AT, type = "response")
pred1     <- as.numeric(mapply(tirage, prob1))
prob2     <- predict(m2, data_AT, type = "response")
pred2     <- as.numeric(mapply(tirage, prob2))
data_AT$yhat <- ifelse(pred1 == 1, "exit", "no_exit")
data_AT$yhat[which(pred1 == 1 & pred2 == 1)] <- "exit_next"
data_AT$yhat[which(pred1 == 1 & pred2 == 0)] <- "exit_oth"
if (length(unique(data_sim$grade)) > 4)
{
data_noAT = data_sim[which(!is.element(data_sim$grade, c("TTH1","TTH2", "TTH3", "TTH4"))), ]
data_noAT$yhat = "no_exit"
data_sim = rbind(data_AT, data_noAT)
}
if (length(unique(data_sim$grade)) <= 4)
{
data_sim = data_AT
}
data_sim = data_sim[order(data_sim$ident), ]
return(data_sim)
}
increment_data_sim <- function(data_sim, simul_py)
{
# Deleting individuals with pbl
if (length(data_sim$ident) != length(simul_py$ident) | length(which(is.na(simul_py$ib)) >0 )  | length(which(is.na(simul_py$grade)) >0 ))
{
list_pbl_id = unique(setdiff(data_sim$ident, simul_py$ident))
print(paste0("Il y a ",length(list_pbl_id)," pr√©sents dans data_sim et absent dans simul"))
list_pbl_ib = unique(simul_py$ident[which(is.na(simul_py$ib))])
print(paste0("Il y a ",length(list_pbl_ib)," individus dans la simul  avec ib = NA"))
list_pbl_grade = unique(simul_py$ident[which(is.na(simul_py$grade) | simul_py$grade == "nan")])
print(paste0("Il y a ",length(list_pbl_grade)," individus dans la simul  avec grade = NA"))
deleted_id = Reduce(union, list(list_pbl_id, list_pbl_ib, list_pbl_grade))
data_sim = data_sim[which(!is.element(data_sim$ident, deleted_id)), ]
simul_py = simul_py[which(!is.element(simul_py$ident, deleted_id)), ]
print(paste0("Il y a ",length(unique(data_sim$ident))," individus dans la base en ", annee+1))
}
# Merge
list_var_kept1 = c("ident",  "sexe", "generation", "an_aff", "c_cir_2011",
"E_exam", "E_choice", "D_exam", "D_choice", "time")
list_var_kept2 = c("annee", "grade", "echelon", "ib", "anciennete_dans_echelon", "situation")
data_merge = cbind(data_sim[,list_var_kept1], simul_py[, list_var_kept2])
# Increment time
data_merge$time[which(data_merge$situation == "no_exit")] = data_merge$time[which(data_merge$situation == "no_exit")] + 1
data_merge$time[which(data_merge$situation != "no_exit")] = 1
# Recreate variables (duration, thresholds with new time and echelons)
data_merge  =  create_variables(data_merge)
return(data_merge)
}
save_results_simul <- function(output, data_sim, modelname)
{
var = c("grade", "anciennete_dans_echelon", "echelon", "ib", "situation")
new_var = paste0(c("grade", "anciennete_dans_echelon", "echelon", "ib", "situation"), "_", modelname )
data_sim[, new_var] = data_sim[, var]
add = data_sim[, c("ident", "annee", new_var)]
# Merge
output = rbind(output, add)
output = output[order(output$ident, output$annee),]
return(output)
}
output_global = generate_data_output(data_path)
for (m in 1:5)
{
if (m <= 3){modelname  =  paste0("MNL_", toString(m))}
if (m == 4){modelname = "BG_1"}
if (m == 5){modelname = "MS_1"}
for (annee in 2011:2012)
{
if (annee == 2011)
{
data_sim = generate_data_sim(data_path, use = "min")
output = data_sim[, c("ident", "annee", "grade","ib", "anciennete_dans_echelon", "echelon")]
output = rename(output, c("grade"=paste0("grade_", modelname) ,
"ib"=paste0("ib_", modelname),
"anciennete_dans_echelon"=paste0("anciennete_dans_echelon_", modelname),
"echelon"=paste0("echelon_", modelname)))
output[, paste0("situation_", modelname)] = NA
}
# Prediction of next_situation from estimated model
if (m <= 3){pred =  predict_next_year_MNL(data_sim, model = list_MNL[[m]], modelname)
if (m == 4){pred =  predict_next_year_seq(data_sim, list(mTTH1, mTTH2, mTTH3, mTTH4), modelname)}
if (m == 5){pred =  predict_next_year_seq(data_sim, step1, step2, modelname)}
# Save prediction for Py simulation
save_prediction_R(data = pred, annee, simul_path, modelname)
# Prediction of next_ib using simulation.py
launch_prediction_Py(annee, modelname)
# Load
simul_py = load_simul_py(annee, modelname)
# Incrementing data_sim for next year
data_sim = increment_data_sim(data_sim, simul_py)
# Save results
output = save_results_simul(output, data_sim, modelname)
}
output_global = merge(output_global, output, by = c("ident", "annee"), all.x = T)
}
output_global = generate_data_output(data_path)
for (m in 1:5)
{
if (m <= 3){modelname  =  paste0("MNL_", toString(m))}
if (m == 4){modelname = "BG_1"}
if (m == 5){modelname = "MS_1"}
print(paste0("Simulation for model ", modelname))
for (annee in 2011:2012)
{
if (annee == 2011)
{
data_sim = generate_data_sim(data_path, use = "min")
output = data_sim[, c("ident", "annee", "grade","ib", "anciennete_dans_echelon", "echelon")]
output = rename(output, c("grade"=paste0("grade_", modelname) ,
"ib"=paste0("ib_", modelname),
"anciennete_dans_echelon"=paste0("anciennete_dans_echelon_", modelname),
"echelon"=paste0("echelon_", modelname)))
output[, paste0("situation_", modelname)] = NA
}
# Prediction of next_situation from estimated model
if (m <= 3){pred =  predict_next_year_MNL(data_sim, model = list_MNL[[m]], modelname)}
if (m == 4){pred =  predict_next_year_seq(data_sim, list(mTTH1, mTTH2, mTTH3, mTTH4), modelname)}
if (m == 5){pred =  predict_next_year_seq(data_sim, step1, step2, modelname)}
# Save prediction for Py simulation
save_prediction_R(data = pred, annee, simul_path, modelname)
# Prediction of next_ib using simulation.py
launch_prediction_Py(annee, modelname)
# Load
simul_py = load_simul_py(annee, modelname)
# Incrementing data_sim for next year
data_sim = increment_data_sim(data_sim, simul_py)
# Save results
output = save_results_simul(output, data_sim, modelname)
}
output_global = merge(output_global, output, by = c("ident", "annee"), all.x = T)
}
m
load(paste0(save_model_path, "by_grade.rda"))
load(paste0(save_model_path, "m_1by_grade.rda"))
load(paste0(save_model_path, "m1_by_grade.rda"))
m = 5
if (m <= 3){modelname  =  paste0("MNL_", toString(m))}
if (m == 4){modelname = "BG_1"}
if (m == 5){modelname = "MS_1"}
print(paste0("Simulation for model ", modelname))
for (annee in 2011:2014)
{
if (annee == 2011)
{
data_sim = generate_data_sim(data_path, use = "min")
output = data_sim[, c("ident", "annee", "grade","ib", "anciennete_dans_echelon", "echelon")]
output = rename(output, c("grade"=paste0("grade_", modelname) ,
"ib"=paste0("ib_", modelname),
"anciennete_dans_echelon"=paste0("anciennete_dans_echelon_", modelname),
"echelon"=paste0("echelon_", modelname)))
output[, paste0("situation_", modelname)] = NA
}
# Prediction of next_situation from estimated model
if (m <= 3){pred =  predict_next_year_MNL(data_sim, model = list_MNL[[m]], modelname)}
if (m == 4){pred =  predict_next_year_seq(data_sim, list(mTTH1, mTTH2, mTTH3, mTTH4), modelname)}
if (m == 5){pred =  predict_next_year_seq(data_sim, step1, step2, modelname)}
# Save prediction for Py simulation
save_prediction_R(data = pred, annee, simul_path, modelname)
# Prediction of next_ib using simulation.py
launch_prediction_Py(annee, modelname)
# Load
simul_py = load_simul_py(annee, modelname)
# Incrementing data_sim for next year
data_sim = increment_data_sim(data_sim, simul_py)
# Save results
output = save_results_simul(output, data_sim, modelname)
}
output_global = merge(output_global, output, by = c("ident", "annee"), all.x = T)
names(output_global)
table(situation_MS_1)
table(output_globalsituation_MS_1)
table(output_globa$lsituation_MS_1)
table(output_global$situation_MS_1)
table(output_global$situation_MNL_1)
table(output_global$situation_MNL_2)
table(output_global$situation_MNL_3)
